> DOTNET no projeto: 


dotNET: Framework feito para desenvolvimento web que, sendo sua função mais falada, permite a reutiliação de códigos e outras funções.

O projeto vai rodar com: 
	dotnet run
e vai retornar qual porta ele está funcionando, informaçoes mais precisas em "Properties/launchSettings.json".

O primeiro arquivo executado é o Program.cs que a partir dele irá puxar o Startup.cs

Já no navegador você vai digitar a porta que foi mostrada, mas com o /swagger que é mostrado em Startup.cs


	<<HTTP e Verbos>>
> Protocolo HTTP: uma ação do cliente se chama Request que segue um padrão:
	-VERBO (A ação requisitada escrita)
	-HEADER (características do content)
	-CONTENT (o próprio conteudo)
   Já o servidor manda uma Response para o cliente que também segue um padrão:
	-Status code
	-HEADER (características do content)
	-CONTENT (o conteudo resposta)

	<<REQUEST>>
 > Verbos principais:
	- GET: requisitar recursos
	- POST: criar recurso
	- PUT: atualiar recurso
	- PATCH: atualiar recurso parcial
	- DELETE: deletar recurso
   existem mais verbos, mas esses são os principais que usam

 > Header: metadados do request
	- Content type: formato do conteúdo
	- Content Lenght: tamanho do conteúdo
	- Authoriation: quem fez a chamada
	- Accept: quais são os tipos aceitáveis
	- Cookies: passagem de dados por requisição
   Existem muitos outros tipos de dados para o header, mas esses não são necessariamente os principais. Vai no estudo de cada caso para saber quais características usar nos headers

 > Content é literalmente o conteúdo do request
	- Pode ser enviado HTML, css, JavaScript, XML, JSON e por aí vai
	- Conteúdo não é válido com qualquer VERBO
	- Informações para ajudar a atenedr o request
	- Onde passar binários e blobs???

	<<RESPONSE>>
 > Status Code: é uma situação da operação que é numerada de 100 à 599. São os famosos erro 404
	- 100-199: Informação 
	- 200-299: Sucesso
	- 300-399: Redirecionamento
	- 400-499: Erro do Cliente
	- 500-599: Erro do Servidor

 > Headers: Metadados semelhantes com os de um request, porém um dado diferente e importante de notar é o Expires que di até quando aquela Response é válida.

 > Content: Também semelhante ao Request, a Response pode ter os mesmos tipos de arquivos enviados, mas é bom dier que na maioria das vees que uma API manda a response será um JSON.

	<<JSON>>

 > JSON (JavaScript Object Notation) é um conjunto de regras para armazenamento e troca de informações em texto.
 > O JSON tende a ser mais otimizado para uso e menor que o XML para a conversão (parse) em outras linguagens.

	<<EF Core>>

	<<Angular>>

 Primeiro passo em um projeto em angular é ver o package.json para ver os comandos além dos padrões.
 > start: ng serve: De alguma forma faz o Angular.json realmente ser lido

 O Angular.json irá dizer os principais informações do projeto, como a primeira página HTML que seria carregada no index ou a Main.ts que seria a parte lógica (JS pré-processado).
A comunicação entre o index.html e o main.ts acontece pelo angular, porém o html irá somente usar as funcionalidades do angular após o index fazer testes de que todos os módulos estão funcionando e então puxa esses módulos (app.modules.ts) que declara os componentes que serão usados no projeto, mas usando o app.components.ts que lista todos os componentes em si.

No módulo terá todos os componentes declarados para conseguir usá-los no html, mas caso os componente tenha o próprio módulo ele deve ser importado para o módulo principal.

> Diretivas: Recursos do angular para manipular o html (funções mais próximas do js)

> Seletor: A maneira como chamar um componente em outros lugares

 Enquanto no backend toda a parte lógica de um evento existe em algum local no projeto, porém suas informações de cada evento está no banco de dados e nossa maneira de interagir com os métodos criados na contoller é pelo localhost swagger como teste, ele está funcionando da maneira desejada. 
 Já no frontend que gira em torno dos componentes se comunicando pelo angular não possui a noção exata do que é o evento, para o front um evento é apenas uma classe que existe, nada mais. Quem irá trazer as características de um evento mais as informações de cada evento é o próprio Angular através do HttpClientModule que vai se conectar com swagger em que eu testo os métodos do back e fazer um request para o swagger mostrsr o resultado dos métodos que ele pode usar, assim enviando as características e informações dos evento.
 Mas de forma reta isso não funcionou como imaginei pois é necessário configurar o CORS.

 >CORS: Configurar é basicamente fazer um método no Startup.cs no backend dizendo que você quer adicionar o CORS:
	services.AddCors();
 E na parte de Configuration do Startup.cs você declara as configurações do CORS: 
	app.UseCors(
		cors => cors.AllowAnyHeader()
			    .AllowAnyMethod()
			    .AllowAnyOrigin()
	);
 Essas autoriações vão fazer esse processo funcionar, mas cada projeto precisa de autorizações diferentes de acordo com as necessidades.

	<<Bootstrap>>

























































---------------------------------------

> Qual é o uso do index.html no projeto já que o arquivo aberto foi o app.component.html?

> Teste unitário

---------------------------------------

---------------------------------------
MVC é uma arquitetura composta por:
	> View - O contato do usuário com o programa
	> Controller - o mediador de informações recebidas da camada view e das respostas do model. Futuramente será apenas o mediador de informações entre camadas com Angular
	> Model - A camada que responderá as informações vindas do controller de acordo.
---------------------------------------



***todo Controller vai ter o sufixo Controller


z